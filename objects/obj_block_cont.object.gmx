<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create block container data structures
//Initialize blocksystem
blocksystem_init();

//Prepare texture vertices
tex_index_map = ds_map_create(); //Maps sprite indexes to their texture indexes on the surface
var tex_set = ds_map_create();
var blocks = block_list();
for(var i=0; i &lt; array_length_1d(blocks); i++) {
    var textures = block_get_textures(blocks[i]);
    for(var j=0; j &lt; 6; j++) {
        if(textures[j]&gt;-1) {
            tex_set[? textures[j]] = 0;
        }
    }
}
var current = ds_map_find_first(tex_set);
for(var i=0; i &lt; ds_map_size(tex_set); i++) {
    tex_index_map[? current] = i;
    current = ds_map_find_next(tex_set, current);
}
tex_number = ds_map_size(tex_set);
var tex_width = 1;
while(tex_width &lt; tex_number) {
    tex_width *= 2;
}
ds_map_destroy(tex_set);

tex_map = ds_map_create(); //Maps block names to their texture arrays
for(var i=0; i &lt; array_length_1d(blocks); i++) {
    var textures = block_get_textures(blocks[i]);
    var indexes = array_create(6);
    for(var j=0; j &lt; 6; j++) {
        indexes[j] = tex_index_map[? textures[j]];
        if(is_undefined(indexes[j])) {
            tex_map[? blocks[i]] = undefined;
            break;
        }
        indexes[j] /= tex_width;
    }
    tex_map[? blocks[i]] = indexes;
}

//Each chunk will be an list of arrays representing each layer
render_distance = 8;
world = ds_map_create();
world_models = ds_map_create();
for(var i=-render_distance; i &lt; render_distance; i++) {
    for(var j=-render_distance; j &lt; render_distance; j++) {
        var coords;
        coords[0] = i;
        coords[1] = j;
        var chunk = chunk_create();
        world[? coords] = chunk;
        chunk_generate(i, j, chunk);
    }
}
for(var i=-render_distance; i &lt; render_distance; i++) {
    for(var j=-render_distance; j &lt; render_distance; j++) {
        var coords;
        coords[0] = i;
        coords[1] = j;
        world_models[? coords] = chunk_model_create(world, coords, tex_map, 1/tex_width);
    }
}

//Set drawing information
grass_texture = sprite_get_texture(spr_grass_top, 0);
draw_set_color(c_white);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free up the space taken by data structures
var current = ds_map_find_first(world);
for(var i = 0; i &lt; ds_map_size(world); i++) {
    ds_list_destroy(world[? current]);
    d3d_model_destroy(world_models[? current]);
    current = ds_map_find_next(world, current);
}
ds_map_destroy(world);
ds_map_destroy(world_models);
ds_map_destroy(tex_map);
ds_map_destroy(tex_index_map);

//Clear the texture surface
surface_free(texture_surface);

//Destroy blocksystem
blocksystem_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update loaded chunks
/*
var current = ds_map_find_first(loaded_chunks);
for(var i=0; i &lt; ds_map_size(loaded_chunks); i++) {
    if(current[0] - (player.x div 16) &gt; render_distance || current[1] - (player.y div 16) &gt; render_distance) {
        ds_map_delete(loaded_chunks, current);
    }
    current = ds_map_find_next(loaded_chunks, current);
}
for(var i=-render_distance; i &lt; render_distance; i++) {
    for(var j=-render_distance; j &lt; render_distance; j++) {
        
    }
}*/

model_queue = ds_list_create();
player_chunk_x = floor(obj_player.x / 16)
player_chunk_y = floor(obj_player.y / 16)
for(var i=player_chunk_x-render_distance; i &lt; player_chunk_x+render_distance; i++) {
    for(var j=player_chunk_y-render_distance; j &lt; player_chunk_y+render_distance; j++) {
        var coords;
        coords[0] = i;
        coords[1] = j;
        if(is_undefined(world[? coords])) {
            var new_chunk = chunk_create();
            world[? coords] = new_chunk;
            chunk_generate(i, j, new_chunk);
            var coords_xp = array_clone(coords);
            coords_xp[0]++;
            var coords_xn = array_clone(coords);
            coords_xn[0]--;
            var coords_yp = array_clone(coords);
            coords_yp[1]++;
            var coords_yn = array_clone(coords);
            coords_yn[1]--;
            ds_list_add(model_queue, coords);
            if(ds_list_find_index(model_queue, coords_xp)==-1 &amp;&amp; !is_undefined(world[? coords_xp]))
                ds_list_add(model_queue, coords_xp);
            if(ds_list_find_index(model_queue, coords_xn)==-1 &amp;&amp; !is_undefined(world[? coords_xn]))
                ds_list_add(model_queue, coords_xn);
            if(ds_list_find_index(model_queue, coords_yp)==-1 &amp;&amp; !is_undefined(world[? coords_yp]))
                ds_list_add(model_queue, coords_yp);
            if(ds_list_find_index(model_queue, coords_yn)==-1 &amp;&amp; !is_undefined(world[? coords_yn]))
                ds_list_add(model_queue, coords_yn);
            world_models[? coords] = chunk_model_create(world, coords, tex_map, 1/tex_number);
        }
    }
}
for(var i = 0; i &lt; ds_list_size(model_queue); i++) {
    world_models[? model_queue[| i]] = chunk_model_create(world, model_queue[| i], tex_map, 1/tex_number);
}
ds_list_destroy(model_queue);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make sure the texture surface is there
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the blocks stored in the chunks
if(is_undefined(texture_surface) || !surface_exists(texture_surface)) {
    d3d_end();
    var tex_width = 1;
    while(tex_width &lt; tex_number) {
        tex_width *= 2;
    }
    tex_width *= 32;
    texture_surface = surface_create(tex_width, 32);
    surface_set_target(texture_surface);
    var current = ds_map_find_first(tex_index_map);
    for(var i=0; i &lt; ds_map_size(tex_index_map); i++) {
        draw_sprite(current, 0, tex_index_map[? current]*32,0);
        current = ds_map_find_next(tex_index_map, current);
    }
    surface_reset_target();
    d3d_start();
}
player_chunk_x = floor(obj_player.x / 16)
player_chunk_y = floor(obj_player.y / 16)
for(var i=player_chunk_x-render_distance; i &lt; player_chunk_x+render_distance; i++) {
    for(var j=player_chunk_y-render_distance; j &lt; player_chunk_y+render_distance; j++) {
        var coords;
        coords[0] = i;
        coords[1] = j;
        d3d_model_draw(world_models[? coords], i*16, j*16, 0, surface_get_texture(texture_surface));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
